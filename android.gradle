apply plugin: 'com.android.library'
apply from: '../constants.gradle'

android {

    compileSdkVersion compileSdkVer
    buildToolsVersion buildToolsVer

    defaultPublishConfig 'release'
    defaultConfig {
        manifestPlaceholders = libraryManifestPlaceholders != null ? libraryManifestPlaceholders : null
        minSdkVersion minSdkVer
        targetSdkVersion targetSdkVer
        versionCode libraryVersionCode
        versionName libraryVersion
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    lintOptions {
        abortOnError false
    }

    packagingOptions {
        exclude 'APK LICENSE.TXT'
        exclude 'LICENSE.TXT'
        exclude 'META-INF/ASL2.0'
        exclude 'META-INF/DEPENDENCIES'
        exclude 'META-INF/INDEX.LIST'
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/NOTICE'
        exclude 'META-INF/NOTICE.txt'
    }
}

//dependencies {
//    compile fileTree(dir: 'libs', include: ['*.jar'])
//    testCompile 'junit:junit:4.12'
//
//    compile "com.android.support:support-annotations:$supLibVersion"
//    compile "com.android.support:appcompat-v7:$supLibVersion"
//    compile "com.android.support:support-v4:$supLibVersion"
//    compile "com.android.support:design:$supLibVersion"
//    compile "com.android.support:recyclerview-v7:$supLibVersion"
//}

/// BEGIN Modular gradle for publishing to JCenter
android {

    // Avoid creating debug
    variantFilter { variant ->
        def build = variant.buildType.name
        if (build.equalsIgnoreCase("debug")) {
            variant.setIgnore(true);
        }
    }

    configurations.maybeCreate(bintrayConfig)

    def Task taskUpload = tasks.findByName('bintrayUpload')
    def boolean bintrayUploadExist = taskUpload != null

    // Base var for pom artifacts
    apply plugin: 'maven'

    /// BASE START
    def generateBase = false
    def customVariant = false

    if (generateBase) {
        // Generate base pom
        def pomOutputDir = "${project.buildDir}/outputs/poms"
        def basePomPath = "${pomOutputDir}/pom.xml"
        def generateBasePom = generatePom(bintrayArtifactName, basePomPath)

        artifacts.add(bintrayConfig, file(basePomPath))

        // Generate base source jar
        def completeSourceSets = android.sourceSets.main.java.srcDirs

        productFlavors.each { flavor ->
            completeSourceSets += android.sourceSets."${flavor.name}".java.srcDirs
        }
        def generateBaseSource = generateSourceJar("", completeSourceSets)

        artifacts.add(bintrayConfig, generateBaseSource)

        // Both are optional for verifying outputs
        build.dependsOn generateBasePom
        build.dependsOn generateBaseSource

        // Linkage to bintrayUpload
        if (bintrayUploadExist) {
            taskUpload.dependsOn generateBasePom
            taskUpload.dependsOn generateBaseSource
        }

    }
    /// BASE END

    /// VARIANT START
    // We don't use `productFlavors.all { flavors-> ... }` since
    // we need to set variant outputs, which productFlavors doesn't have
    if (customVariant) {
        libraryVariants.all { variant ->

            def variantArtifactName = "$variant.flavorName"
            println("Variant name: " + variantArtifactName)

            //AAR artifacts
            def fileRef = variant.outputs[0].outputFile

            def artifactFullName = generateString(variantArtifactName)
            def artifactAar = artifactFullName + ".aar"
            def artifactPom = artifactFullName + ".pom"

            def variantFileOutput = new File(fileRef.parentFile, artifactAar)
            variant.outputs[0].outputFile = variantFileOutput; //IMPORTANT

            artifacts.add(bintrayConfig, variantFileOutput)

            // Source jar artifacts
            def sourceTask = generateSourceJar(variantArtifactName,
                    android.sourceSets."${variantArtifactName}".java.srcDirs)

            artifacts.add(bintrayConfig, sourceTask)

            // Variants pom
            def pomPathVariant = "${pomOutputDir}/${artifactPom}"
            def pomTask = generatePom(variantArtifactName, pomPathVariant)

            artifacts.add(bintrayConfig, file(pomPathVariant))

            def javadocJarTask = generateJavadocJar(variant)

            artifacts.add(bintrayConfig, javadocJarTask)

            if (bintrayUploadExist) {
                taskUpload.dependsOn sourceTask
                taskUpload.dependsOn pomTask
                taskUpload.dependsOn javadocJarTask
            }
            // These are optional for verifying outputs
            build.dependsOn sourceTask
            build.dependsOn pomTask
            build.dependsOn javadocJarTask
        }
    }
    /// VARIANT END
}

// Core name generation
def generateString(String variantArtifactName) {
    //return "${project.name}-${project.version}-${variantArtifactName}" //OLD
    return "${variantArtifactName}-${project.version}"
}

// Source generation
def Task generateSourceJar(String sourceArtifactName, Object... sourceSetPaths) {
    return project.task("sourcesJar${sourceArtifactName.capitalize()}", type: Jar) {
        group 'publishing'
        baseName sourceArtifactName
        classifier "sources"
        from sourceSetPaths
//        destinationDir = new File("${project.buildDir}/outputs/sources/")
    }
}

// Javadoc generation
//def Task generateJavadocJar(com.android.build.gradle.api.LibraryVariant variant) {
//    def javadocTaskName = "javadoc${variant.flavorName.capitalize()}"
//    def javadocJarTaskName = "javadocJar${variant.flavorName.capitalize()}"
//
//    task(javadocTaskName, type: Javadoc) {
//        title = "${variant.flavorName.capitalize()} API"
//        group = 'javadoc'
//        source = variant.javaCompile.source
//        options.links("http://docs.oracle.com/javase/7/docs/api/");
//        options.linksOffline("http://d.android.com/reference", "${android.sdkDirectory}/docs/reference");
//
//        // First add all of your dependencies to the classpath, then add the android jars
//        classpath += files(variant.javaCompile.classpath.files)
//        classpath += files(android.getBootClasspath())
//
//        // We're excluding these generated files
//        exclude '**/BuildConfig.java'
//        exclude '**/R.java'
//        failOnError = false
//    }
//
//    return task(javadocJarTaskName, type: Jar, dependsOn: javadocTaskName) {
//        group = 'publishing'
//        baseName variant.flavorName
//        classifier = 'javadoc'
//        from tasks[javadocTaskName].destinationDir
//    }
//}

// POM Generation
def Task generatePom(String pomArtifactName, String destPath) {
    return project.task("pom${pomArtifactName.capitalize()}") {
        description "Generates a pom.xml for ${pomArtifactName}"
        group 'publishing'
        pom {
            project {
                name pomArtifactName.capitalize()
                groupId publishedGroupId
                artifactId pomArtifactName
                version libraryVersion
                packaging 'aar'
                inceptionYear yearBegan
                licenses {
                    license {
                        name licenseName
                        url licenseUrl
                        distribution 'repo'
                    }
                }
            }
        }.withXml {
            // As per https://gist.github.com/delor/f70560f14674b322dcd2
            def dependenciesNode = asNode().appendNode('dependencies')

            configurations.compile.allDependencies.each { dependency ->

                if ("unspecified".equalsIgnoreCase(dependency.name) || null == dependency.name)
                    return

                def dependencyNode = dependenciesNode.appendNode('dependency')
                dependencyNode.appendNode('groupId', dependency.group)
                dependencyNode.appendNode('artifactId', dependency.name)
                dependencyNode.appendNode('version', dependency.version)
                dependencyNode.appendNode('scope', 'compile') //since we checked from configurations.compile
            }
        }.writeTo(destPath)
    }
}

/// END Modular gradle

afterEvaluate {
    apply from: '../install.gradle'
    apply from: '../bintray.gradle'
    bintrayUpload.dependsOn install
}
