package com.baseconfig.pillar.databinding.recycler;

import android.databinding.ViewDataBinding;
import android.support.annotation.NonNull;
import android.support.v7.util.DiffUtil;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.ViewGroup;

import java.util.List;
import java.util.ListIterator;

/**
 * RecyclerView adapter for a list of T objects where its layouts implemented databinding. <br>
 * Example #1: <br>
 * Given a list of Student objects to be displayed in a recycler view, the adapter below is created:
 * <pre>{@code
 * public class MyAdapter extends BindingItemAdapter<Student> {
 *      ...
 *      @Override
 *      public BindingHolder<? extends ViewDataBinding> onCreateBindingHolder(LayoutInflater inflater, ViewGroup parent, int viewType) {
 *          return new BindingHolder<>(DataBindingUtil.inflate(inflater, R.layout.my_list_item_layout, parent, false));
 *      }
 *
 *      @Override
 *      public void onBind(BindingHolder<? extends ViewDataBinding> holder, Student item, int position) {
 *          ViewDataBinding binding = holder.getBinding();
 *          if (binding instanceof MyListItemLayoutBinding) { //MyListItemLayoutBinding is generated by the databinding library
 *              MyListItemLayoutBinding b = ((ModuleListItemHeaderBinding) binding);
 *              b.titleTextView.setText(item.getStudentName());
 *          }
 *      }
 * }
 * }</pre>
 * Example #2 (complex): <br>
 * 1. You have multiple view types for list item (section headers, and actual list item) <br>
 * 2. You have to display a list of Classroom where each Classroom object contains a list of Students (sectioning) <br>
 * <pre>{@code
 * public class MyActivity extends AppCompatActivity{
 *      @Override
 *      public void onCreate(Bundle onSaveInstanceState){
 *          ...
 *          List<Classroom> classrooms = retrieveClassrooms(); //sample collection
 *          RecyclerView rv = binding.recyclerView; //or (RecyclerView) findViewById(R.id.recyclerView) etc.
 *          rv.setAdapter(new Adapter(FlatData.getCollection(classrooms, new FlatData.Factory<Classroom, Student>() {
 *              @Override
 *              public String getName(Classroom group) {
 *              return group.getClassroomName();
 *              }
 *
 *              @Override
 *              public List<Student> getSubgroupList(Classroom classroom) {
 *              return classroom.getStudents();
 *              }
 *          })));
 *          ...
 *      }
 * }
 *
 * public class MyAdapter extends BindingItemAdapter<FlatData<Classroom, Student>> {
 *      ...
 *      @Override
 *      public int getItemViewType(int position) {
 *          // isHeader() method is provided by {@link FlatData } class
 *          return getList().get(position).isHeader() ? R.layout.list_header_classroom : R.layout.list_item_student;
 *      }
 *
 *      @Override
 *      public BindingHolder<? extends ViewDataBinding> onCreateBindingHolder(LayoutInflater inflater, ViewGroup parent, int viewType) {
 *          // notice we directly use the viewType as suggested by the official support library
 *          return new BindingHolder<>(DataBindingUtil.inflate(inflater, viewType, parent, false));
 *      }
 *
 *      @Override
 *      public void onBind(BindingHolder<? extends ViewDataBinding> holder, FlatData<Classroom, Student> item, int position) {
 *          ViewDataBinding binding = holder.getBinding();
 *          if (binding instanceof ListHeaderClassroomBinding) {
 *              ListHeaderClassroomBinding b = (ListHeaderClassroomBinding) binding;
 *              b.headerTextView.setText(item.getName()); //getName() method is provided by {@link FlatData } class
 *          }
 *          else if(binding instanceof ListItemStudentBinding){
 *              ListItemStudentBinding b = (ListItemStudentBinding) binding;
 *              b.studentNameTextView.setText(item.getSubgroup().getStudentName()); //getSubgroup() method is provided by {@link FlatData } class
 *
 *              // FlatData just reference the original dataset. Refer {@link FlatData } for more details
 *          }
 *      }
 * }
 * }</pre>
 * <p>
 * <p>
 * Simple list methods are also provided but feel free to roll your own implementation if you have a specialized list.
 */

@SuppressWarnings("WeakerAccess")
public abstract class BindingItemAdapter<T> extends RecyclerView.Adapter<BindingHolder<? extends ViewDataBinding>> {

    protected List<T> collection;

    public List<T> getCollection() {
        return collection;
    }

    public void setCollection(List<T> list) {
        this.collection = list;
    }

    @Override
    public BindingHolder<? extends ViewDataBinding> onCreateViewHolder(final ViewGroup parent, final int viewType) {
        return onCreateBindingHolder(LayoutInflater.from(parent.getContext()), parent, viewType);
    }

    public abstract BindingHolder<? extends ViewDataBinding> onCreateBindingHolder(LayoutInflater inflater, ViewGroup parent, final int viewType);

    @Override
    public void onBindViewHolder(final BindingHolder<? extends ViewDataBinding> holder, final int position) {
        onBind(holder, collection.get(position), position);
        holder.getBinding().executePendingBindings();
    }

    @Override
    public int getItemCount() {
        return collection == null ? 0 : collection.size();
    }

    public abstract void onBind(final BindingHolder<? extends ViewDataBinding> holder, final T t, final int position);

    /**
     * Remove item from the list
     */
    public void removeItem(@NonNull T t) {
        ListIterator<T> iterator = getCollection().listIterator();
        while (iterator.hasNext()) {
            int i = iterator.nextIndex();
            T next = iterator.next();
            if (t.equals(next)) {
                iterator.remove();
                notifyItemRemoved(i);
                break;
            }
        }
    }

    /**
     * Add item to the last of the list
     */
    public void addItem(T t) {
        int size = getCollection().size();
        getCollection().add(t);
        notifyItemInserted(size);
    }

    /**
     * Notify item changed for the given item
     */
    public void notifyItemChanged(T t) {
        notifyItemChanged(collection.indexOf(t));
    }

    /**
     * Update the backing list with new list of a probably similar objects.
     * This uses {@link DiffUtil} in the implementation.
     *
     * @param callback DiffUtil callback that is used to determine object updates.
     * @param list     New list that is separate from the original backing list.
     */
    public void updateList(final List<T> list, DiffUtil.Callback callback) {
        if (collection == null) {
            collection = list;
            notifyItemRangeInserted(0, collection.size());
        } else {
            DiffUtil.calculateDiff(callback).dispatchUpdatesTo(this);
            collection = list;
        }
    }

}
